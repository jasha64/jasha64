//10.131.235.233 - 计数器 
//递归求解的思想 
#include <iostream>
using namespace std;

void statNum(int sn[10], int n)
{
	for (int k = 0, s = 0, pow10 = 1; n > 0; k++, n /= 10, pow10 *= 10) //循环不变式k的意义：已经统计了n的最后k位组成的数的答案 
	{
		int c = n % 10; //n的第k+1位上的数 
		for (int i = 0; i < 10; i++) sn[i] += k * c * pow10 / 10; //后k位上，数字0~9各出现了k*c*10^k次 
		for (int i = 0; i < c; i++) sn[i] += pow10; //第k+1位上，数字0~(c-1)各出现了10^k次 
		//以上两步统计了[0, (cek)-1]区间的k+1位数产生的答案（不足k+1位的是用0补齐的） 
		sn[c] += 1 + s; //第k+1位上，数字c出现了s+1次 
		//因为以前的步骤已经统计完[0, s]产生的答案，此步完成后即统计了[cek, (cek)+s]产生的答案 
		sn[0] -= pow10; //将前面有补0的方案个数扣除
		//通过数学推导可以算出[0, n]答案中总共补0的个数等于10^k+10^(k-1)+...+10+1，这里k是n的总位数
		//为了方便，就将扣除补0的步骤也写进这个循环中 
		s += c * pow10; //更新s，更新后s表示n的后k+1位组成的数，用来求出第k+2位上的数字在第k+2位上出现的次数 
		//这样一来就统计完了[0, s]区间的答案 
    }
    //相当于一个尾递归的非递归写法。先求解n的后k位组成的数对应的答案，然后再求出
	//所有符合条件的k+1位数对答案的贡献，即可递推出n的后k+1位组成的数对应的答案。 
}

int main()
{
	int cnt[10] = {}, n;
	cin >> n;
	statNum(cnt, n);
	for (int i = 0; i < 10; i++) cout << cnt[i] << endl;
	return 0;
}
//参考资料: https://blog.csdn.net/wxq_wuxingquan/article/details/60778637 

